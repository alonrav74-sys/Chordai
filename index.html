<!doctype html>  
<html lang="he" dir="rtl">  
<head>  
  <meta charset="utf-8" />  
  <meta name="viewport" content="width=device-width, initial-scale=1" />  
  <title>Chord Finder AI â€” v9.4.6 (Harmonic Live Sheet)</title>  
  <meta name="theme-color" content="#0b1022" />  
  <!-- PWA hooks -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      });
    }
  </script>
  <style>  
    :root{--bg:#0b1022;--panel:#0f172a;--muted:#94a3b8;--text:#e5e7eb;--card:#0a1324;--border:#1b2333;--brand:#22c55e;--accent:#38bdf8;--alert:#f59e0b}  
    *{box-sizing:border-box}  
    body{margin:0;background:linear-gradient(160deg,var(--bg),#0a0f1c);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#e5e7eb;direction:rtl}  
    .wrap{max-width:1120px;margin:auto;padding:18px}  
    h1{margin:6px 0 10px;font-size:24px}  
    .muted{color:var(--muted);font-size:14px}  
    .panel{background:#0c162b;border:1px solid #1f2a40;border-radius:16px;padding:14px;margin-top:12px}  
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}  
    input[type="file"], select, button, input[type="number"]{padding:10px 14px;border-radius:12px;border:1px solid #223;background:#0b1221;color:#cfe3ff;appearance:none;font-weight:700;cursor:pointer}  
    .badge{display:inline-flex;gap:6px;align-items:center;background:#0b1221;border:1px solid #1f2937;color:#cbd5e1;border-radius:999px;padding:6px 10px;font-size:12px}  
    .badge.ai{border-color:#23664d;background:#0d2e1f;color:#d7ffe6}  
    .live{background:#0c162b;border:1px solid #1f2a40;border-radius:16px;padding:18px;display:flex;align-items:center;justify-content:space-between;margin-top:10px}  
    .live .title{color:#a9b4c8;font-size:13px}  
    .live .ch{font-weight:800;font-size:42px}  
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;line-height:1.6;direction:ltr;text-align:left}  
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #2a3d55;margin:2px 4px;background:#0b1221}  
    .ok{border-color:#1f5f3f;color:#d7ffe6;background:#0d2e1f}  
    .err{border-color:#5f2323;color:#ffe0e0;background:#3f1d1d}  
    .warn{border-color:#8a6a1f;color:#fff0d9;background:#3a2a0c}  
    .spin{width:12px;height:12px;border-radius:50%;border:2px solid var(--accent);border-top-color:transparent;animation:sp 1s linear infinite}  
    @keyframes sp{to{transform:rotate(360deg)}}  
    progress{width:240px;height:10px;border-radius:8px;overflow:hidden}  
    .mutedSmall{color:#94a3b8;font-size:12px}  
    .chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;background:#0b1221;border:1px solid #1f2a40;font-size:12px}  
    .chip .dot{width:6px;height:6px;border-radius:50%;background:#22c55e}  
    .chip.warn .dot{background:#f59e0b}  
    .chip.err .dot{background:#ef4444}  
  </style>  
</head>  
<body>  
  <div class="wrap">  
    <h1>ğŸµ Chord Finder AI â€” v9.4.6 (Harmonic Live Sheet) <span class="mutedSmall">â€¢ harmonic+pause + cautious 7/sus</span></h1>  
    <div class="muted">×× ×•×¢ 9.x ××§×•×¨×™ â€¢ ×“×£ ×—×™ ×—×›× ×œ×¤×™ ×¤×•× ×§×¦×™×•×ª ×”×¨××•× ×™×•×ª + ××ª× ×—×ª×•×ª + ×‘×§×¨×ª ×¨×’×™×©×•×ª ×œâ€‘7/sus â€¢ ×‘×œ×™ ×“×£ ×¡×˜×˜×™ â€¢ ×›×•×ª×‘ ××©×××œ ×œ×™××™×Ÿ, ×¢×“ 7 ××§×•×¨×“×™× ×‘×©×•×¨×”.</div>  
  
    <section class="panel">  
      <div class="row">  
        <input id="file" type="file" accept="audio/*,video/*" />  
        <label>××¦×‘ ×”×¨×—×‘×•×ª:  
          <select id="extMode">  
            <option value="triad">×˜×¨×™××“×•×ª ×‘×œ×‘×“</option>  
            <option value="smart" selected>×—×›× (sus/7 ×¨×§ ×‘×•×•×“××•×ª)</option>  
          </select>  
        </label>  
        <label>×§×•×•×× ×˜×”:  
          <select id="quant"><option value="2">1/2</option><option value="4" selected>1/4</option><option value="8">1/8</option></select>  
        </label>  
        <label>ğŸ¸ ×§××¤×•:  
          <input id="capo" type="number" value="0" min="0" max="9" style="width:80px" />  
        </label>  
        <label><input type="checkbox" id="deep" /> × ×™×ª×•×— ×¢××•×§ (×¢×“ ~30 ×©× ×™×•×ª)</label>  
        <button id="analyzeBtn">× ×ª×—</button>  
        <button id="playBtn" disabled>ğŸ§ ×”×¤×¢×œ ×©××¢</button>  
        <span class="badge">BPM: <b id="bpm">â€”</b></span>  
        <span class="badge">××©×š: <b id="dur">â€”</b></span>  
        <span class="badge">×˜×•× ×™×§×”: <b id="tonicBadge">â€”</b></span>  
        <span class="badge">×¡×•×œ×: <b id="keyBadge">â€”</b></span>  
        <span id="aiBadge" class="badge ai" style="display:none">AI</span>  
      </div>  
      <div id="status" class="pill ok" style="display:none"></div>  
      <div id="error" class="pill err" style="display:none"></div>  
      <div class="row">  
        <progress id="prog" max="100" value="0" style="display:none"></progress>  
        <span id="progTxt" class="mutedSmall"></span>  
        <span id="gateChip" class="chip warn" style="display:none"><span class="dot"></span>××—×›×” ×œ×¤×¨×™×˜×” ×××™×ª×™×ªâ€¦</span>  
      </div>  
    </section>  
  
    <section class="panel">  
      <h2>×ª×¦×•×’×ª ××§×•×¨×“ ×—×™ ×‘×–××Ÿ × ×™×’×•×Ÿ</h2>  
      <audio id="player" controls preload="auto" crossorigin="anonymous" style="width:100%"></audio>  
      <div class="live">  
        <div class="title">×”××§×•×¨×“ ×›×¨×’×¢</div>  
        <div class="ch" id="liveChord">â€”</div>  
      </div>  
      <div class="mutedSmall">×”×“×£ ×œ××˜×” × ×‘× ×” ×‘×–××Ÿ × ×™×’×•×Ÿ ×‘×œ×‘×“, ××©×××œ ×œ×™××™×Ÿ. ×™×¨×™×“×ª ×©×•×¨×” ×›×©×™×© ××ª× ×—×ª×/×§××“× ×¦×” ××• ××—×¨×™ 7 ××§×•×¨×“×™×.</div>  
    </section>  
  
    <section class="panel">  
      <h2>ğŸ“ ×“×£ × ×’×™× ×” â€” ×‘×–××Ÿ ×××ª (×”×¨××•× ×™×” + ××ª× ×—×ª×)</h2>  
      <div id="liveSheet" class="mono">â€”</div>  
      <div class="row" style="margin-top:8px">  
        <button id="resetSheet">××¤×¡ ×“×£ ×—×™</button>  
      </div>  
    </section>  
  </div>  
  
<script type="module">  
// ===== UI refs =====  
const fileEl=document.getElementById('file');  
const analyzeBtn=document.getElementById('analyzeBtn');  
const playBtn=document.getElementById('playBtn');  
const statusEl=document.getElementById('status');  
const errorEl=document.getElementById('error');  
const prog=document.getElementById('prog'); const progTxt=document.getElementById('progTxt');  
const gateChip=document.getElementById('gateChip');  
const player=document.getElementById('player');  
const bpmEl=document.getElementById('bpm'); const durEl=document.getElementById('dur');  
const quantEl=document.getElementById('quant'); const deepEl=document.getElementById('deep');  
const capoEl=document.getElementById('capo'); const tonicBadge=document.getElementById('tonicBadge'); const keyBadge=document.getElementById('keyBadge');  
const liveChordEl=document.getElementById('liveChord'); const liveSheetEl=document.getElementById('liveSheet');  
const resetSheetBtn=document.getElementById('resetSheet'); const aiBadge=document.getElementById('aiBadge');  
  
function showAnalyzing(stepText){ statusEl.innerHTML='<span class="spin"></span> '+stepText; statusEl.className='pill warn'; statusEl.style.display='inline-flex'; }  
function ok(msg){ statusEl.textContent=msg; statusEl.className='pill ok'; statusEl.style.display='inline-flex'; }  
function err(msg){ errorEl.textContent=msg; errorEl.style.display='inline-flex'; }  
function hideAlerts(){ statusEl.style.display='none'; errorEl.style.display='none'; prog.style.display='none'; progTxt.textContent=''; gateChip.style.display='none'; }  
  
// ===== Musical helpers =====  
const NOTES_SHARP=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];  
const NOTES_FLAT =['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];  
const MAJOR_SCALE=[0,2,4,5,7,9,11], MINOR_SCALE=[0,2,3,5,7,8,10];  
const toPc=n=>((n%12)+12)%12;  
const nameSharp=i=>NOTES_SHARP[toPc(i)]; const nameFlat=i=>NOTES_FLAT[toPc(i)];  
const dot=(a,b)=>a.reduce((s,x,i)=>s+x*b[i],0);  
const norm=a=>Math.sqrt(a.reduce((s,x)=>s+x*x,0))||1;  
const cos=(a,b)=>dot(a,b)/(norm(a)*norm(b));  
function maskVec(root, pcs){ const v=new Array(12).fill(0); pcs.forEach(iv=>v[(root+iv)%12]=1); return v; }  
function parseRoot(label){ const m=label?.match?.(/^([A-G](?:#|b)?)/); if(!m) return -1; const nm=m[1].replace('b','#'); const i=NOTES_SHARP.indexOf(nm); return i<0?-1:i; }  
function applyCapoToLabel(label, capo){  
  if(!capo || capo===0) return label;  
  const m=label.match(/^([A-G](?:#|b)?)(.*)$/); if(!m) return label;  
  const idx=NOTES_SHARP.indexOf(m[1].replace('b','#')); if(idx<0) return label;  
  const newPc = toPc(idx - capo);  
  return nameFlat(newPc)+(m[2]||'');  
}  
  
// ===== Krumhansl profiles =====  
const KS_MAJOR=[6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88];  
const KS_MINOR=[6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17];  
function ksScore(chromaAgg, root, isMinor){  
  const prof=(isMinor? KS_MINOR: KS_MAJOR);  
  let s=0; for(let i=0;i<12;i++){ s += chromaAgg[toPc(i+root)] * prof[i]; } return s;  
}  
function inKey(pc, keyRoot, minor){ const sc = minor? MINOR_SCALE: MAJOR_SCALE; return sc.includes(toPc(pc-keyRoot)); }  
  
// ===== Analysis pipeline =====  
analyzeBtn.onclick=async()=>{  
  hideAlerts(); aiBadge.style.display='none';  
  liveChordEl.textContent='â€”'; liveSheetEl.textContent='â€”'; playBtn.disabled=true; tonicBadge.textContent='â€”'; keyBadge.textContent='â€”';  
  const f=fileEl.files?.[0]; if(!f){ err('×‘×—×¨ ×§×•×‘×¥ ××•×“×™×•/×•×™×“××•'); return; }  
  try{  
    const deep=deepEl.checked;  
    showAnalyzing('×× ×ª×—â€¦ ×©×œ×‘ 1/4: ×˜×¢×™× ×ª ××•×“×™×•');  
    if(deep){ prog.value=8; prog.style.display='block'; progTxt.textContent='×˜×¢×™× ×”â€¦'; }  
    const st1 = await decodeAudio(f);  
    bpmEl.textContent = st1.bpm; durEl.textContent = st1.duration.toFixed(1)+'s';  
    const url = URL.createObjectURL(f); player.src=url;  
  
    showAnalyzing('×× ×ª×—â€¦ ×©×œ×‘ 2/4: ××™×¦×•×™ ×›×¨×•××”/×‘×¡');  
    if(deep){ prog.value=28; progTxt.textContent='××™×¦×•×™ ×›×¨×•××” ×•×‘×¡â€¦'; }  
    const feats = extractFeatures(st1);  
  
    showAnalyzing('×× ×ª×—â€¦ ×©×œ×‘ 3/4: ×¡×•×œ× (Krumhansl) + HMM');  
    if(deep){ prog.value=60; progTxt.textContent='×—×™×©×•×‘ ×¡×•×œ×â€¦'; }  
    const key = estimateKeyKrumhansl(feats, deep, st1.duration);  
    if(deep){ prog.value=75; progTxt.textContent='×”×—×œ×§×ª ××§×•×¨×“×™× (HMM)â€¦'; }  
    const timeline = chordTrackingWithHMM(feats, key);  
  
    showAnalyzing('×× ×ª×—â€¦ ×©×œ×‘ 4/4: × ×™×§×•×™ ×•×–×× ×™ ×”×¦×’×”');  
    if(deep){ prog.value=92; progTxt.textContent='Min-×“uration, Grid ×•×©××™×¨×ª ×§×™×©×•×˜×™ 7/Bassâ€¦'; }  
    const finalTL = finalizeTimeline(timeline, key, st1.bpm, feats);  
  
    // NoiseGate + energy track  
    const gateIdx = detectStartGate(feats);  
    const gateTime = Math.max(0, gateIdx) * (feats.hop/feats.sr);  
    const energyTimes = feats.frameE.map((_,i)=> i*(feats.hop/feats.sr));  
    const energyVals = normalize01(feats.frameE);  
  
    // decorate qualities (cautious 7/sus/dim/aug) using chroma+bass context  
    const mode = document.getElementById('extMode').value;  
    const decoratedTL = decorateQualities(finalTL, feats, key, mode);  
  
    const capo=parseInt(capoEl.value||'0',10);  
    tonicBadge.textContent = applyCapoToLabel(nameSharp(key.root)+(key.minor?'m':''), capo);  
    keyBadge.textContent = applyCapoToLabel(nameSharp(key.root)+(key.minor?'m':''), capo);  
    window.__STATE = { bpm: st1.bpm, duration: st1.duration, timeline: decoratedTL, key, gateTime, energy:{t:energyTimes, v:energyVals}, feats:{hop:feats.hop,sr:feats.sr} };  
    ok('×”× ×™×ª×•×— ×”×•×©×œ× âœ“ â€” ××¤×©×¨ ×œ×”×©××™×¢');  
    if(deep){ prog.value=100; progTxt.textContent='××•×›×Ÿ'; }  
    hookPlaybackLive(); playBtn.disabled=false; aiBadge.style.display='inline-flex';  
  }catch(e){ console.error(e); err('×”×“×¤×“×¤×Ÿ ×œ× ×”×¦×œ×™×— ×œ×¤×¢× ×—/×œ× ×ª×—. × ×¡×” MP3/WAV ××• ×“×¤×“×¤×Ÿ ××—×¨.'); }  
};  
  
playBtn.onclick=async()=>{ try{ await player.play(); }catch(e){ alert('×œ×—×¥ â–¶ï¸ ×¢×œ ×”× ×’×Ÿ ×›×“×™ ×œ××©×¨ × ×™×’×•×Ÿ ×‘×“×¤×“×¤×Ÿ ×–×”.'); } };  
  
// ===== Stages =====  
async function decodeAudio(file){  
  const arr = await file.arrayBuffer();  
  const AC = window.AudioContext || window.webkitAudioContext;  
  const ctx = new AC();  
  const buf = await ctx.decodeAudioData(arr.slice(0));  
  const mono = (buf.numberOfChannels===1)? buf.getChannelData(0) : mixStereo(buf);  
  const sr0=buf.sampleRate, sr=22050;  
  const x = resampleLinear(mono, sr0, sr);  
  const bpm = 120;  
  return { x, sr, bpm, duration: x.length/sr };  
}  
  
function extractFeatures(st1){  
  const {x,sr} = st1;  
  const hop=Math.floor(0.10*sr), win=4096;  
  const hann=new Float32Array(win); for(let i=0;i<win;i++) hann[i]=0.5*(1-Math.cos(2*Math.PI*i/(win-1)));  
  const frames=[]; for(let s=0; s+win<=x.length; s+=hop) frames.push(x.subarray(s,s+win));  
  function fft(input){ let n=input.length,N=1; while(N<n)N<<=1; const re=new Float32Array(N),im=new Float32Array(N); re.set(input);  
    let j=0; for(let i=0;i<N;i++){ if(i<j){ [re[i],re[j]]=[re[j],re[i]]; [im[i],im[j]]=[im[j],im[i]]; } let m=N>>1; while(m>=1&&j>=m){ j-=m; m>>=1; } j+=m; }  
    for(let len=2; len<=N; len<<=1){ const ang=-2*Math.PI/len, wlr=Math.cos(ang), wli=Math.sin(ang);  
      for(let i=0;i<N;i+=len){ let wr=1, wi=0;  
        for(let k=0;k<(len>>1);k++){  
          const ur=re[i+k], ui=im[i+k];  
          const vr=re[i+k+(len>>1)]*wr - im[i+k+(len>>1)]*wi;  
          const vi=re[i+k+(len>>1)]*wi + im[i+k+(len>>1)]*wr;  
          re[i+k]=ur+vr; im[i+k]=ui+vi;  
          re[i+k+(len>>1)]=ur-vr; im[i+k+(len>>1)]=ui-vi;  
          const nwr=wr*wlr - wi*wli; wi=wr*wli + wi*wlr; wr=nwr;  
        }  
      }  
    }  
    const mags=new Float32Array(N>>1); for(let k=0;k<mags.length;k++) mags[k]=Math.hypot(re[k],im[k]);  
    return {mags,N};  
  }  
  const hz=(b,N)=>b*sr/N;  
  const chroma=[], bassPc=[], frameE=[];  
  for(let i=0;i<frames.length;i++){  
    const y=new Float32Array(win); for(let k=0;k<win;k++) y[k]=frames[i][k]*hann[k];  
    const {mags,N}=fft(y);  
    let en=0; for(let b=1;b<mags.length;b++){ en+=mags[b]; }  
    frameE.push(en);  
    const c=new Float32Array(12); let e=0;  
    for(let b=1;b<mags.length;b++){ const f=hz(b,N); if(f<80||f>5000) continue; const midi=69+12*Math.log2(f/440); const pc=toPc(Math.round(midi)); c[pc]+=mags[b]; e+=mags[b]; }  
    if(e>0){ let s=0; for(let k=0;k<12;k++) s+=c[k]; for(let k=0;k<12;k++) c[k]/=s; }  
    chroma.push(c);  
    // bass  
    let bestHz=0,best=0;  
    for(let b=1;b<mags.length;b++){  
      const f=hz(b,N); if(f<40)continue; if(f>250)break;  
      const v=mags[b], b2=Math.round(b*2), b3=Math.round(b*3);  
      const score = v + (mags[b2]||0)*0.6 + (mags[b3]||0)*0.4;  
      if(score>best){ best=score; bestHz=f; }  
    }  
    const pc = bestHz>0 ? toPc(Math.round(69+12*Math.log2(bestHz/440))) : -1;  
    bassPc.push(pc);  
  }  
  return { chroma, bassPc, frameE, hop:Math.floor(0.10*sr), sr };  
}  
  
function estimateKeyKrumhansl(feats, deep, duration){  
  const {chroma}=feats;  
  const L = chroma.length;  
  const maxFrames = deep? Math.min(L, Math.floor(30/(feats.hop/feats.sr))) : L;  
  const agg=new Array(12).fill(0);  
  for(let i=0;i<maxFrames;i++){ for(let p=0;p<12;p++) agg[p]+=chroma[i][p]; }  
  const s=agg.reduce((a,b)=>a+b,0)||1; for(let p=0;p<12;p++) agg[p]/=s;  
  let best={score:-1, root:0, minor:false};  
  for(let r=0;r<12;r++){  
    const sMaj=ksScore(agg,r,false), sMin=ksScore(agg,r,true);  
    if(sMaj>best.score){ best={score:sMaj, root:r, minor:false}; }  
    if(sMin>best.score){ best={score:sMin, root:r, minor:true}; }  
  }  
  return {root:best.root, minor:best.minor};  
}  
  
function chordTrackingWithHMM(feats, key){  
  const {chroma,bassPc,hop,sr,frameE}=feats;  
  const diatonic = (key.minor? MINOR_SCALE: MAJOR_SCALE).map(s=>toPc(key.root+s));  
  const candidates=[];  
  for(const r of diatonic){ candidates.push({root:r,label:nameSharp(r)}); candidates.push({root:r,label:nameSharp(r)+'m'}); }  
  function emitScore(i,cand){  
    const c=chroma[i]; if(!c) return -Infinity;  
    const isMinor = /m$/.test(cand.label);  
    const mask = isMinor? maskVec(cand.root,[0,3,7]) : maskVec(cand.root,[0,4,7]);  
    let s = cos([...c],mask);  
    if(bassPc[i]>=0 && cand.root===bassPc[i]) s+=0.15;  
    if(frameE[i] < percentileLocal(frameE,30)) s -= 0.10;  
    return s;  
  }  
  const T=(a,b)=>{  
    if(a.label===b.label) return 0.0;  
    const dist = Math.min((b.root-a.root+12)%12,(a.root-b.root+12)%12);  
    const sameQual = /m$/.test(a.label)===/m$/.test(b.label);  
    let penalty = 0.6 + 0.1*dist + (sameQual?0.0:0.05);  
    return penalty;  
  };  
  const N=candidates.length, M=chroma.length;  
  const dp=new Array(N).fill(0);  
  const backptr=Array.from({length:M},()=>new Array(N).fill(-1));  
  for(let s=0;s<N;s++) dp[s]=emitScore(0,candidates[s]);  
  for(let i=1;i<M;i++){  
    const newdp=new Array(N).fill(-Infinity);  
    for(let s=0;s<N;s++){  
      let bestVal=-Infinity, bestJ=-1;  
      for(let j=0;j<N;j++){  
        const val = dp[j] - T(candidates[j], candidates[s]);  
        if(val>bestVal){ bestVal=val; bestJ=j; }  
      }  
      newdp[s]=bestVal + emitScore(i,candidates[s]);  
      backptr[i][s]=bestJ;  
    }  
    for(let s=0;s<N;s++) dp[s]=newdp[s];  
  }  
  let bestS=0, bestVal=-Infinity;  
  for(let s=0;s<N;s++){ if(dp[s]>bestVal){ bestVal=dp[s]; bestS=s; } }  
  const states=new Array(M); states[M-1]=bestS;  
  for(let i=M-1;i>0;i--) states[i-1]=backptr[i][states[i]];  
  const tl=[]; const secPerHop = hop/sr;  
  let cur=states[0], start=0;  
  for(let i=1;i<M;i++){  
    if(states[i]!==cur){  
      tl.push({t:start*secPerHop, label:candidates[cur].label, fi:start});  
      cur=states[i]; start=i;  
    }  
  }  
  tl.push({t:start*secPerHop, label:candidates[cur].label, fi:start});  
  return tl;  
}  
  
function finalizeTimeline(tl, key, bpm, feats){  
  const spb=60/Math.max(60,Math.min(200,bpm||120));  
  const minDur=Math.max(0.5, 0.45*spb);  
  const out=[];  
  for(let i=0;i<tl.length;i++){  
    const a=tl[i]; const b=tl[i+1]; const dur=(b?b.t: a.t+4*spb) - a.t;  
    if(dur<minDur && out.length){  
      const fiA=a.fi, fiB=(b?b.fi:fiA+1);  
      const bpA = feats.bassPc[fiA] ?? -1;  
      const bpB = feats.bassPc[Math.min(feats.bassPc.length-1, fiB)] ?? -1;  
      const bassChanged = (bpA>=0 && bpB>=0 && bpA!==bpB);  
      if(!bassChanged){  
        const prev=out[out.length-1];  
        const r=parseRoot(a.label), pr=parseRoot(prev.label);  
        const inA=inKey(r, key.root, key.minor), inP=inKey(pr, key.root, key.minor);  
        if(!inA || inP){ continue; }  
      }  
    }  
    out.push(a);  
  }  
  const snapped=[];  
  for(const ev of out){  
    const q=Math.max(0, Math.round(ev.t/spb)*spb);  
    if(!snapped.length || snapped.at(-1).label!==ev.label){  
      snapped.push({t:q, label:ev.label, fi:ev.fi});  
    }  
  }  
  return snapped;  
}  
  
// ===== Quality decoration =====  
function decorateQualities(tl, feats, key, mode){  
  if(mode!=='smart') return tl.map(e=>({...e}));  
  const out=[];  
  for(const ev of tl){  
    const root=parseRoot(ev.label); if(root<0){ out.push(ev); continue; }  
    const isMinor=/m$/.test(ev.label);  
    let base=ev.label.replace(/(m|sus2|sus4|dim|aug|7|m7b5|\(\w+\))$/,'');  
    if(isMinor) base+='m';  
    const i0=Math.max(0, ev.fi-2), i1=Math.min(feats.chroma.length-1, ev.fi+2);  
    const avg=new Float32Array(12);  
    for(let i=i0;i<=i1;i++){ const c=feats.chroma[i]; for(let p=0;p<12;p++) avg[p]+=c[p]||0; }  
    for(let p=0;p<12;p++) avg[p]/=(i1-i0+1);  
    const fifth = (avg[toPc(root+7)]||0);  
    const s2 = avg[toPc(root+2)]||0;  
    const s4 = avg[toPc(root+5)]||0;  
    const sFlat5 = avg[toPc(root+6)]||0;  
    const sMaj3 = avg[toPc(root+4)]||0;  
    const sMin3 = avg[toPc(root+3)]||0;  
    const sB7 = avg[toPc(root+10)]||0;  
    const sSharp5 = avg[toPc(root+8)]||0;  
    const sRoot = avg[root]||0;  
  
    let label = base;  
  
    const thirdWeak = (/m$/.test(base)? sMin3 : sMaj3) < 0.11;  
    const sus2Strong = s2 > 0.22 && s2 > s4*0.9;  
    const sus4Strong = s4 > 0.22 && s4 > s2*0.9;  
    if(!/m$/.test(base) && thirdWeak){  
      if(sus4Strong){ label = base.replace(/m$/,'') + 'sus4'; }  
      else if(sus2Strong){ label = base.replace(/m$/,'') + 'sus2'; }  
    }  
  
    const deg = degreeOfChord(label, key);  
    const likelyDom = (deg===4);  
    const b7Strong = (sB7 > 0.20) && (sB7 > Math.max(sMaj3,sMin3)*0.75) && (sRoot > 0.12);  
    if(!/sus/.test(label) && !/m$/.test(label) && (likelyDom ? (sB7 > 0.17) : b7Strong)){  
      label += '7';  
    }  
  
    if(/m$/.test(base) && sFlat5 > 0.25 && fifth < 0.10 && sMin3 > 0.14){  
      if(deg===1){ label = base.replace(/m$/,'m7b5'); }  
    }  
    if(!/m$/.test(base) && sSharp5 > 0.28 && fifth < 0.12 && sMaj3 > 0.16){  
      label = base.replace(/m$/,'') + 'aug';  
    }  
  
    out.push({...ev, label});  
  }  
  return out;  
}  
  
// ===== Harmonic helpers for line breaks =====  
function degreeOfChord(label, key){  
  const rootPc = parseRoot(label);  
  if(rootPc<0) return null;  
  const rel = toPc(rootPc - key.root);  
  const scale = key.minor? MINOR_SCALE : MAJOR_SCALE;  
  let bestDeg = null, bestDist=999;  
  for(let d=0; d<scale.length; d++){  
    const scPc = scale[d];  
    const dist = Math.min((rel-scPc+12)%12,(scPc-rel+12)%12);  
    if(dist<bestDist){ bestDist=dist; bestDeg=d; }  
  }  
  return bestDeg;   
}  
function isCadence(prevLabel, curLabel, key){  
  const dPrev = degreeOfChord(prevLabel,key);  
  const dCur = degreeOfChord(curLabel,key);  
  return (dPrev===4 && dCur===0);  
}  
function isSubdominantToDominant(prevLabel, curLabel, key){  
  const dPrev=degreeOfChord(prevLabel,key);  
  const dCur=degreeOfChord(curLabel,key);  
  return (dPrev===3 && dCur===4);  
}  
function energyAt(t, energy){  
  const {t:times, v:vals}=energy;  
  if(!times?.length) return 0;  
  let lo=0, hi=times.length-1;  
  while(lo<hi){  
    const mid=(lo+hi)>>1;  
    if(times[mid]<t) lo=mid+1; else hi=mid;  
  }  
  const i=Math.max(0,Math.min(times.length-1,lo));  
  return vals[i];  
}  
function normalize01(arr){  
  if(!arr?.length) return [];  
  let mn=Infinity,mx=-Infinity;  
  for(const v of arr){ if(Number.isFinite(v)){ if(v<mn) mn=v; if(v>mx) mx=v; } }  
  const d=(mx-mn)||1;  
  return arr.map(v=> (v-mn)/d );  
}  
  
// ===== Live playback =====  
function hookPlaybackLive(){  
  const st=window.__STATE; if(!st) return;  
  const capo=parseInt(capoEl.value||'0',10);  
  const spb=60/(st.bpm||120);  
  const minPauseSec=Math.max(1.0, 1.75*spb);  
  const maxPerLine=7;  
  
  let lines=[]; let currentLine=[];   
  let lastChord=null; let lastChangeSec=0;  
  liveSheetEl.textContent='â€”';  
  gateChip.style.display='inline-flex';  
  
  player.ontimeupdate=()=>{  
    const t=player.currentTime;  
    if(t < st.gateTime){ liveChordEl.textContent='â€”'; return; }  
    if(gateChip.style.display!=='none') gateChip.style.display='none';  
  
    let i=st.timeline.findIndex(x=>x.t>t);  
    if(i===-1) i=st.timeline.length;  
    const ev=st.timeline[i-1]||st.timeline[0];  
    if(!ev) return;  
    const shown = applyCapoToLabel(ev.label, capo);  
    liveChordEl.textContent = shown;  
  
    if(shown!==lastChord){  
      const pause = (t-lastChangeSec) > minPauseSec;  
      const eNow = energyAt(t, st.energy);  
      const ePrev = energyAt(Math.max(0,t-0.4), st.energy);  
      const energyDrop = (ePrev>0.25 && (eNow < ePrev*0.55));  
  
      const cadenceBreak = lastChord ? isCadence(lastChord, shown, st.key) : false;  
      const sdToDom = lastChord ? isSubdominantToDominant(lastChord, shown, st.key) : false;  
  
      const needBreak =   
          (currentLine.length>=maxPerLine)  
          || cadenceBreak  
          || (pause && energyDrop)  
          || (sdToDom && currentLine.length>=4);  
  
      if(needBreak && currentLine.length){  
        lines.push(currentLine.join('   '));  
        currentLine=[];  
      }  
  
      currentLine.push(shown);  
  
      const text=[...lines, currentLine.join('   ')].filter(s=>s && s.length).join('\n');  
      liveSheetEl.textContent = text || 'â€”';  
  
      lastChord=shown;  
      lastChangeSec=t;  
    }  
  };  
  
  resetSheetBtn.onclick=()=>{  
    lines=[]; currentLine=[]; lastChord=null; lastChangeSec=player.currentTime;  
    liveSheetEl.textContent='â€”';  
  };  
}  
  
// ===== NoiseGate (start only) =====  
function detectStartGate(feats){  
  const {frameE,bassPc,chroma}=feats;  
  const N=frameE.length;  
  const energies=[...frameE].filter(x=>Number.isFinite(x)).sort((a,b)=>a-b);  
  const med = energies[Math.floor(energies.length*0.5)] || 0;  
  const thr = med*1.8;  
  const needStable=3; let run=0;  
  for(let i=0;i<N;i++){  
    const strong = frameE[i]>thr;  
    const hasBass = bassPc[i]>=0;  
    let chromaPeak=false;  
    if(chroma[i]){  
      let mx=0; for(let k=0;k<12;k++) mx=Math.max(mx, chroma[i][k]||0);  
      chromaPeak = mx>0.18;  
    }  
    if((strong || hasBass) && chromaPeak){ run++; if(run>=needStable) return i-needStable+1; }  
    else run=0;  
  }  
  return 0;  
}  
  
// ===== Utils =====  
function mixStereo(buf){ const a=buf.getChannelData(0), b=(buf.numberOfChannels>1?buf.getChannelData(1):a); const m=new Float32Array(buf.length); for(let i=0;i<buf.length;i++) m[i]=(a[i]+b[i])*0.5; return m; }  
function resampleLinear(x,sr,target){ const r=target/sr, L=Math.floor(x.length*r), y=new Float32Array(L); for(let i=0;i<L;i++){ const t=i/r, i0=Math.floor(t), i1=Math.min(x.length-1,i0+1), a=t-i0; y[i]=x[i0]*(1-a)+x[i1]*a; } return y; }  
function percentileLocal(arr, p){ const a=[...arr].filter(x=>Number.isFinite(x)).sort((x,y)=>x-y); if(!a.length) return 0; const i=Math.floor((p/100)*(a.length-1)); return a[i]; }  
</script>  
</body>  
</html>  
